# 问
```c++
unordered_map<int, int> mp;

vector<int> res;

for(int i=0; i<nums1.size(); i++) {

mp[nums1[i]]++;

}

for(int i=0; i<nums2.size(); i++) {

if(mp[nums2[i]]>0) {
mp[nums2[i]] = 0;
res.push_back(nums2[i]);
}
}
return res;
```

上面这一段代码和下面这一段代码

```c++
unordered_set<int> result_set;
int hash[1005] = {0};
for (int num : nums1) {
hash[num] = 1;
}
for (int num : nums2) {
if (hash[num] == 1) {
result_set.insert(num);
}
}
return vector<int>(result_set.begin(), result_set.end()); 
```  
时间复杂度相同，为什么运行时间下面更快

# 答
两段代码的时间复杂度确实相同，都是 O(n + m)，其中 n 和 m 分别是 `nums1` 和 `nums2` 的大小。然而，运行时间的差异主要源于数据结构的常数因子开销和缓存效率。以下是详细解释：

### 1. **数据结构开销**：
- 第一段代码使用 `unordered_map`，这是一个基于哈希表的关联容器。每次访问 `mp[nums2[i]]` 都需要计算哈希值、处理潜在冲突、进行链表遍历等操作，这些操作虽然平均时间复杂度为 O(1)，但常数因子较高。
- 第二段代码使用一个固定大小的数组 `hash[1005]`。数组访问是直接通过索引进行的，即 `hash[num]`，这只需要一个内存偏移量，操作非常快，常数因子极低。数组的初始化（全部设置为0）也很快，因为内存是连续的。

### 2. **缓存效率**：
- 数组 `hash` 在内存中是连续分配的，因此访问模式非常缓存友好。当遍历 `nums2` 时，对 `hash` 的访问容易命中 CPU 缓存，减少内存延迟。
- `unordered_map` 的内存布局通常更分散（由于哈希桶和链表结构），访问模式可能随机，导致缓存缺失较多，从而增加运行时间。

### 3. **操作复杂度**：
- 在第一段代码中，对于每个元素 in `nums2`，需要执行两次 `unordered_map` 操作：一次检查 `mp[nums2[i]] > 0`（包括查找和比较），另一次设置 `mp[nums2[i]] = 0`（包括查找和更新）。每次操作都有查找开销。
- 在第二段代码中，对于每个元素 in `nums2`，只需一次数组访问和比较（`hash[num] == 1`），操作更轻量。虽然插入 `unordered_set` 也有开销，但只对交集元素进行（通常较小），因此整体开销较低。

### 4. **值范围假设**：
- 第二段代码使用固定大小数组 `hash[1005]`，这假设了 `nums1` 和 `nums2` 中的值都在 [0, 1004] 范围内。如果值在这个范围内，数组访问非常高效；但如果值范围很大，数组方法就不适用（但根据代码，这里似乎值范围较小）。
- 第一段代码使用 `unordered_map`，可以处理任意整数值，但付出了通用性的代价，导致速度较慢。

### 总结：
尽管时间复杂度相同，第二段代码运行更快是因为它利用了数组的直接索引访问，这些操作具有更低的常数因子和更好的缓存性能。而 `unordered_map` 虽然灵活，但开销较大。在性能关键的场景中，如果值范围已知且较小，使用数组通常比哈希表更高效。